(defun test-next-interrupt ()
  (reset-state)
  (let* ((interrupts (list (make-interrupt :time 10 :result (lambda () (print "hey")))
                           (make-interrupt :time 20 :result (lambda () (print "hey")))))
         (*context* (make-context :storage-jobs-table nil :transfers nil :interrupts interrupts))
         (res-time (interrupt-time (next-interrupt)))
         (*context* (make-context :interrupts (list)))
         (res1 (next-interrupt))
         (res (and (= res-time 10) (null res1))))
    (print res-time)
    (print res)
    res))

(defun int-run-test ()
  "Tests evaluation of policies. Tests the integration with next-interrupt by having actions that sets more interrupts."
  (reset-state)
  (let* ((flag nil)
         (next-interrupt-set nil)
         (pol1 (make-policy :conditions (list (lambda () t)) :actions (list (lambda () (print "action"))
                                                                            (lambda () (if (not (null flag)) flag (setf flag t)))
                                                                            (lambda () (when (null next-interrupt-set)
                                                                                         (setf (context-interrupts *context*) (list (make-interrupt :time 10 :result (lambda () (print "interrupt processed")))))
                                                                                         (setf next-interrupt-set t)))))))
    (run nil (list pol1))
    (equal (funcall (second (policy-actions pol1))) t)))

(defun test-add-obj-to-location ()
  (reset-state)
  (let* ((job (copy-job (first *jobs*)))
         (burst-length (length (job-bursts job)))
         (s-j-t (list (cons *tape* nil)
                      (cons *disk* nil)
                      (cons *dma* nil)
                      (cons *memory* nil)
                      (cons *memory-input* nil)))
         (*context* (make-context :storage-jobs-table s-j-t :transfers nil :interrupts nil :time 0)))
    (add-obj-to-location *memory* job)
    (format t "~%Simple add:~a~%"
            (and (equal job (job-in-location *memory*))
                 (> (holder-allocated *memory*) 0)))
    (remove-obj-from-location *memory*)
    (setf (job-bursts job) (cdr (job-bursts job)))
    (add-obj-to-location *memory* job)
    (let* ((final-job (job-in-location *memory*))
           (final-b-length (length (job-bursts final-job))))
      (and (not (null final-job))
           (= final-b-length (- burst-length 1))))))

(defun int-jobs-only-on-tape-test (jobs)
  "Tests jobs-only-on-tape and consequently job-in-location"
  (reset-state)
  (let* ((s-j-t (list (cons *tape* jobs) (cons *disk* nil) (cons *dma* nil) (cons *memory* nil) (cons *memory-input* nil)))
         (s-j-t-f (list (cons *tape* jobs) (cons *disk* (list (first jobs))) (cons *dma* nil) (cons *memory* nil) (cons *memory-input* nil)))
         (*context* (make-context :storage-jobs-table s-j-t :transfers nil :interrupts nil))
         (test1 (jobs-only-on-tape))
         (*context* (make-context :storage-jobs-table s-j-t-f :transfers nil :interrupts nil))
         (test2 (jobs-only-on-tape)))
    (and test1 (not test2))))

(defun test-get-transfer-params ()
  (equal *tape->disk* (get-transfer-params *tape* *disk*)))

(defun int-move-with-result-test (jobs)
  (reset-state)
  (let* ((s-j-t (list (cons *tape* jobs) (cons *disk* nil) (cons *dma* nil) (cons *memory* nil) (cons *memory-input* nil)))
         (*context* (make-context :storage-jobs-table s-j-t :transfers nil :interrupts nil :time 0))
         (flag nil))
    (move-with-result *tape* *disk* (first jobs) (lambda () (setf flag t)))
    (next-interrupt)
    (format t "Job on disk? ~a~%Flag? ~a" (job-in-location *disk*) flag)
    (and (job-in-location *disk*)
         (equal flag t))))

(defun int-consume-input-and-bursts-test ()
  (reset-state)
  (let* ((job (copy-job (first *jobs*)))
         (s-j-t (list (cons *tape* nil)
                      (cons *disk* nil)
                      (cons *dma* nil)
                      (cons *memory* (list job))
                      (cons *memory-input* (list (make-input :size 25)))))
         (*context* (make-context :storage-jobs-table s-j-t :transfers nil :interrupts nil :time 0))
         (start-bursts (job-bursts job))
         (start-inputs (job-inputs job)))
    (consume-input job)
    (consume-burst job)
    (let ((new-job (remove-obj-from-location *memory* job)))
      (and (= (length start-bursts) (+ (length (job-bursts new-job)) 1))
           (= (length start-inputs) (+ (length (job-inputs new-job)) 1))))))

(defun test-job-needs-input (jobs)
  (reset-state)
  (let* ((job (copy-job (first jobs)))
         (s-j-t (list (cons *tape* nil)
                      (cons *disk* nil)
                      (cons *dma* nil)
                      (cons *memory* (list job))
                      (cons *memory-input* nil)))
         (*context* (make-context :storage-jobs-table s-j-t :transfers nil :interrupts nil :time 0))
         (res1 nil)
         (res2 nil))
    (move-with-result *tape* *disk* (make-input :size 25) (lambda ()
                                                            (move-with-result *disk* *memory-input*
                                                                              (make-input :size 25) nil)))
    (setf (context-interrupts *context*) (remove (next-interrupt) (context-interrupts *context*))) ;;moving takes two hops
    (setf (context-interrupts *context*) (remove (next-interrupt) (context-interrupts *context*)))
    (setf res1 (job-needs-input (job-in-location *memory*)))
    (format t "~%Needs input while input in mem-in?~%")
    (princ res1) ;no,input in memory
    (run-job)
    (setf (context-interrupts *context*) (remove (next-interrupt) (context-interrupts *context*)))
    (run-job)
    (setf (context-interrupts *context*) (remove (next-interrupt) (context-interrupts *context*)))
    (when (not (null (job-in-location *memory-input*)))
      (error "input was not consumed."))
    (setf res2 (job-needs-input (job-in-location *memory*)))
    (format t "~%Needs input after mem-in has been consumed?~%")
    (princ res2)
    (and (not res1) res2)))

(defun run-tests ()
  (format t "~%Test next interrupt: ~a ~%" (test-next-interrupt))
  (format t "~%Integrated run test: ~a ~%" (int-run-test))
  (format t "~%Jobs only on tape test: ~a ~%" (int-jobs-only-on-tape-test *jobs*))
  (format t "~%Get transfer params: ~a ~%" (test-get-transfer-params))
  (format t "~%Integrated move with result test: ~a ~%" (int-move-with-result-test *jobs*))
  (format t "~%Add obj to location: ~a ~%" (test-add-obj-to-location))
  (format t "~%Integrated consumption test: ~a ~%" (int-consume-input-and-bursts-test))
  ;(princ (int-consume-input-or-cpu-time-test *jobs*))
  (princ (test-job-needs-input *jobs*)))

